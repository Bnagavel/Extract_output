# %%

""" Generates and plots a 3D surface from ABAQUS data points using Delaunay triangulation. 

    Input Files:
        ABAQUS input file with node numbers and nodal coordinates.
        ABAQUS report file with node numbers, NCURS (Nodal current, a scalar) and ECD (Electrical current density, a vector) data.
        
    Output Files:
        Image files of 3D surface plot of the NCURS and ECD data.
        
"""

# Importing the required libraries
import numpy as np
import scipy
from matplotlib import pyplot as plt
from scipy.spatial import Delaunay

def read_abaqus_input_file(file_path):
  
  # ABAQUS input file with node numbers and nodal coordinates
  # *Heading
  # E2_211_300x300_00_AllEdges_ins_Aligned
  # ** Job name: E2_211 Model name: Model-1
  # ** Generated by: Abaqus/CAE 2017
  # *Preprint, echo=NO, model=NO, history=NO, contact=NO
  # **
  # ** PARTS
  # **
  # *Part, name=Part-1
  # *Node
  #      1,  -5.47667694,   1.12071931,        0.147
  #      2,  -4.82962894,  -1.29409528,        0.147
  # *Element, type=DC3D8E
  # ...
  # End of file
   
  # Open the file and read the lines
  with open(file_path, 'r') as file:
    lines = file.readlines()
    
  # Initialize dictionary to store the node numbers and nodal coordinates
  # Node number is the key and the nodal coordinates are the values
  nodes = { }
  
  # Loop over the lines and extract the node numbers and nodal coordinates
  for line in lines:
    if line.startswith('*Node'):
      for line in lines[lines.index(line)+1:]:
        if line.startswith('*'):
          break
        elif line.startswith('EPOT'):
          break
        else:
            #      1,  -5.47667694,   1.12071931,        0.147
            # Split the line and extract the nodal coordinates
            # Store node number and node coordinates in a dictionary
          node_number = int(line.split(',')[0])
          node_coordinates = [float(x) for x in line.split(',')[1:]]
          nodes[node_number] = node_coordinates          
          
  return nodes



def read_abaqus_report_file_ECD(file_path):
  
#********************************************************************************
#Field Output Report, written Wed Feb 21 15:47:46 2024

# ...
#   Element Label      Node Label           NCURS   ECD.Magnitude        ECD.ECD1        ECD.ECD2        ECD.ECD3
#                                          @Loc 1          @Loc 1          @Loc 1          @Loc 1          @Loc 1
#-----------------------------------------------------------------------------------------------------------------
#               1               1     50.6991E-03     159.973E-03    -932.070E-03     115.353E-06    -61.4617E-06
#               1               2     66.7449E-03         1.33402    -922.488E-03    -128.729E-06    -61.6543E-06

#
#  Minimum                           -112.625E-03     12.1321E-12        -1.01725    -330.916E-06    -65.4858E-06
# ...
#           Total                     15.7227E-09     1.06395E+03     4.78826E-03    -185.427E-09    -87.0518E-03
# End of file


  # Open the file and read the lines
  with open(file_path, 'r') as file:
    lines = file.readlines()
    
  # Initialize node_output dictionaries to store the node numbers, NCURS and ECD data
  node_output = {}
 
  
  # Loop over the lines and extract the node numbers, NCURS and ECD data
  for line in lines:
    if line.startswith('   Element Label'):
      for line in lines[lines.index(line)+3:]:
        if line.startswith('  Minimum'):
          break
        else:
#   Element Label      Node Label           NCURS   ECD.Magnitude        ECD.ECD1        ECD.ECD2        ECD.ECD3          
#               1               1     50.6991E-03     159.973E-03    -932.070E-03     115.353E-06    -61.4617E-06
          # Extract the node numbers and ECD data and store in node_output dictionary
          if line.strip()!='':
            node_number = int(line.split()[1])
            ECD = [float(x) for x in line.split()[3:]]
            node_output[node_number] = [ECD]
           
  return node_output


# Main program
# Read the ABAQUS input file
nodes = read_abaqus_input_file('E2_211.inp')

# Read the ABAQUS report file
node_output = read_abaqus_report_file_ECD('E2_211.rpt')

# Save the nodes dictionary to a text file
with open('nodes.txt', 'w') as file:
  for node_number, node_coordinates in nodes.items():
    file.write(f"{node_number}, {', '.join(map(str, node_coordinates))}\n")

# Save the node_output dictionary to a text file
with open('node_output.txt', 'w') as file:
  for node_number, node_data in node_output.items():
    file.write(f"{node_number}, {', '.join(map(str, node_data))}\n")

# The nodal coodinates are in XY plane with different Z values
# Find the unique Z values
z_values = np.unique([node[2] for node in nodes.values()])
# Nodal coordinates X & Y of each node and node numbers of each Z plane are extracted and stored in a dictionary
nodes_z = {}
for z in z_values:
  nodes_z[z] = {node_number: node_coordinates[:2] for node_number, node_coordinates in nodes.items() if node_coordinates[2] == z}

  
# Print first 5 nodes of each Z plane
for z, nodes in nodes_z.items():
  print(f"Z = {z}")
  for node_number, node_coordinates in list(nodes.items())[:5]:
    print(f"Node {node_number}: {node_coordinates}")
  print()
  
# Create ECD_maginitude dictionary to store the ECD magnitude data
ECD_magnitude = {}
for node_number, ECD in node_output.items():
  ECD_magnitude[node_number] = ECD[0][0]


# Node numbers and ECD magnitude data of each Z plane are extracted and stored in a dictionary
ECD_magnitude_z = {}
for z, nodes in nodes_z.items():
  ECD_magnitude_z[z] = {node_number: ECD_magnitude[node_number] for node_number in nodes.keys()}
  
# Print first 5 ECD magnitude of each Z plane
for z, ECD_magnitudes in ECD_magnitude_z.items():
  print(f"Z = {z}")
  for node_number, ECD_magnitude in list(ECD_magnitudes.items())[:5]:
    print(f"Node {node_number}: {ECD_magnitude}")
  print()
  
# Create a dictionary of lists contains node numbers, node_coordinates and ECD magnitude for each Z plane
ECD_magnitude_z_plot_data = {}
for z, nodes in nodes_z.items():
  ECD_magnitude_z_plot_data[z] = [list(nodes.keys()), list(nodes.values()), list(ECD_magnitude_z[z].values())]
  
# Print first 5 node numbers, node_coordinates and ECD magnitude of each Z plane
for z, plot_data in ECD_magnitude_z_plot_data.items():
  print(f"Z = {z}")
  for node_number, node_coordinates, ECD_magnitude in list(zip(*plot_data))[:5]:
    print(f"Node {node_number}: {node_coordinates}, ECD Magnitude: {ECD_magnitude}")
  print()
  
# Plot the ECD magnitude data for each Z plane
for z, plot_data in ECD_magnitude_z_plot_data.items():
  plt.figure(figsize=(8, 6))
  plt.scatter([node[0] for node in plot_data[1]], [node[1] for node in plot_data[1]], c=plot_data[2], cmap='viridis')
  plt.colorbar(label='ECD Magnitude')
  plt.title(f"ECD Magnitude at Z = {z}")
  plt.xlabel("X")
  plt.ylabel("Y")
  plt.show()
  
# 3D Surface plot of ECD magnitude for all Z planes
for z, plot_data in ECD_magnitude_z_plot_data.items():
  fig = plt.figure(figsize=(8, 6))
  ax = fig.add_subplot(111, projection='3d')
  ax.scatter([node[0] for node in plot_data[1]], [node[1] for node in plot_data[1]], plot_data[2], c=plot_data[2], cmap='viridis')
  ax.set_title(f"ECD Magnitude at Z = {z}")
  # Set limits
  ax.set_xlim(min([node[0] for node in plot_data[1]]), max([node[0] for node in plot_data[1]]))
  ax.set_ylim(min([node[1] for node in plot_data[1]]), max([node[1] for node in plot_data[1]]))
  ax.set_zlim(min(plot_data[2]), max(plot_data[2]))
  ax.set_xlabel("X")
  ax.set_ylabel("Y")
  ax.set_zlabel("ECD Magnitude")
  plt.show()
  
  
# Create numpy arrays of X, Y and ECD magnitude data for each Z plane
X = {}
Y = {}
Z = {}
ECD_magnitude = {}
for z, plot_data in ECD_magnitude_z_plot_data.items():
  X[z] = np.array([node[0] for node in plot_data[1]])
  Y[z] = np.array([node[1] for node in plot_data[1]])
  Z[z] = np.array([z]*len(plot_data[0]))
  ECD_magnitude[z] = np.array(plot_data[2])

# Create delaunay triangulation for each Z plane
triangulation = {}
for z in z_values:
  triangulation[z] = Delaunay(np.array([X[z], Y[z]]).T)
  
# Plot the 3D surface of ECD magnitude for all Z planes
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')
for z in z_values:
  ax.plot_trisurf(X[z], Y[z], ECD_magnitude[z], triangles=triangulation[z].simplices, cmap='viridis')
ax.set_title("ECD Magnitude")
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("ECD Magnitude")
plt.show()



# %%